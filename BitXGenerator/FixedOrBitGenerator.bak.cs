using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Differencing;
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using System.Xml.Linq;

namespace BitX;

[Generator(LanguageNames.CSharp)]
public partial class FixedOrBitGenerator : IIncrementalGenerator
{

    public static ConcurrentDictionary<int, string> CachedFixedCode = new();
    public static ConcurrentDictionary<long, string> CachedBitCode = new();

    public const string FixedFileHead = @"// <auto-generated/>
#nullable enable
#pragma warning disable CS0108
#pragma warning disable CS0162
#pragma warning disable CS0164
#pragma warning disable CS0219
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8604
#pragma warning disable CS8619
#pragma warning disable CS8620
#pragma warning disable CS8631
#pragma warning disable CS8765
#pragma warning disable CS9074
#pragma warning disable CA1050

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System;";




    private static string GetBaseTypeByBitSizeAndOffset(int bitSizeAndOffset, string typeName) =>
       bitSizeAndOffset switch
       {
           <= 8 => "byte",
           <= 16 => "ushort",
           <= 32 => "uint",
           <= 64 => "ulong",
           _ => throw new ArgumentException($"unsupported bit Size And Offset: {bitSizeAndOffset}", typeName),
           //<= 128 => "UInt128",
       };

    public static ulong GetMaxByBitCount(int bitCount)
    {
        ulong result = 0;
        for (var i = 0; i < bitCount; i++)
            result |= (1UL << i);//此处或运算亦可为加运算

        //直接使用次方API实现,暂不使用此方法.
        //        if (input > 0)
        //            output = (UInt64)Math.Pow(2, (int)input) - 1;
        return result;
    }

    /// <summary>
    /// 对于增量的代码生成，只需要有 Initialize 方法即可，所有逻辑都在这个方法里面实现
    /// 按照官方的设计，将会分为三个步骤完成增量代码生成：
    /// 告诉框架层需要关注哪些文件的变更
    /// 在有对应的文件的变更情况下，才会触发后续步骤。如此就是增量代码生成的关键
    /// 告诉框架层从变更的文件里面感兴趣什么数据，对数据预先进行处理
    /// 预先处理过程中，是会不断进行丢掉处理的
    /// 其中第一步和第二步可以合在一起
    /// 使用给出的数据进行处理源代码生成逻辑
    /// 这一步的逻辑和普通的 Source Generator 是相同的，只是输入的参数不同
    /// </summary>
    /// <param name="context"></param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //DebugHelper.Debug();
        //DebugHelper.Trace();
        //context.RegisterImplementationSourceOutput
        //Debugger.Launch();

        //context.RegisterPostInitializationOutput(x => {
        //    x.AddSource("Fixed.cs", "abc");

        //});

        var incrementalValuesProvider = context.SyntaxProvider.CreateSyntaxProvider(
            FilterSyntaxTargetForGeneration
            , FilterSemanticTargetForGeneration);
            //.Collect().SelectMany((myObjects, _) => myObjects.Distinct());

        //var generatorAttributes = 
        //    context.SyntaxProvider.ForAttributeWithMetadataName("BitX.FixedAttribute<T>",
        //    (_, _) => true,
        //    (syntaxContext, _) => syntaxContext
        //);

        //context.RegisterSourceOutput(generatorAttributes, GenerateFixedAttribute);





        context.RegisterSourceOutput(incrementalValuesProvider, static (spc, ffd) =>
        {

            if (ffd.Length>0)
            {
                foreach(var v in ffd)
                {
                    if (v.HasValue)
                    {
                        if (v.Value.IsFixedOrBit)
                            FixedBufferGenerate(spc, v.Value);
                        else
                            BitFieldTypeGenerate(spc, v.Value);
                    }
                }
            }
            //var fieldTypeSynTax = fds.Declaration.Type;
            //if (fieldTypeSynTax is GenericNameSyntax fieldTypeGenericNameSynTax
            //&& fieldTypeGenericNameSynTax.Arity == 1
            //&& fieldTypeGenericNameSynTax.TypeArgumentList.Arguments.FirstOrDefault() is IdentifierNameSyntax genericArgumentTypeSyntax)
            //{
            //    var fieldType_GenericTypeName = fieldTypeGenericNameSynTax.Identifier.Text;
            //    var fieldType_GenericType_ArgumentTypeName = genericArgumentTypeSyntax.Identifier.Text;
            //    var sizeTxt = fieldType_GenericTypeName.Replace("Fixed", "");
            //    spc.AddSource($"{fieldType_GenericTypeName}.g.cs", string.Format(StructTemplate, sizeTxt));
            //}
        });

        //Step1_FindFiles(context);
    }

    private static void FixedBufferGenerate(SourceProductionContext spc, FixedOrBitMemberDesc ffd)
    {
        //        var code = $@"{FixedFileHead}
        //[InlineArray({ffd.FixedOrBitSize})]
        //public struct Fixed{ffd.FixedOrBitSize}<T>
        //{{
        //    private T _element0;

        //    public const int Length = {ffd.FixedOrBitSize};

        //    public Span<T> GetSpan() => MemoryMarshal.CreateSpan(ref Unsafe.As<Fixed{ffd.FixedOrBitSize}<T>, T>(ref this), {ffd.FixedOrBitSize});

        //    T this[int index] {{ get => this[index]; set => this[index] = value; }}
        //}}";
        //        spc.AddSource($"Fixed{ffd.FixedOrBitSize}.g.cs", code);

        var code = CachedFixedCode.GetOrAdd(ffd.FixedOrBitSize, $@"
[InlineArray({ffd.FixedOrBitSize})]
public struct Fixed{ffd.FixedOrBitSize}<T>
{{
    private T _element0;

    public const int Length = {ffd.FixedOrBitSize};

    public Span<T> GetSpan() => MemoryMarshal.CreateSpan(ref Unsafe.As<Fixed{ffd.FixedOrBitSize}<T>, T>(ref this), {ffd.FixedOrBitSize});

    T this[int index] {{ get => this[index]; set => this[index] = value; }}
}}");
        StringBuilder sb = new StringBuilder();
        sb.Append(FixedFileHead);
        sb.Append(code);
        //foreach (var typeCode in CachedFixedCode.Values)
        //    sb.AppendLine(typeCode);
        spc.AddSource($"Fixed{ffd.FixedOrBitSize}.g.cs", sb.ToString());
    }



    private static void BitFieldTypeGenerate(SourceProductionContext spc, FixedOrBitMemberDesc ffd)
    {
        var size = ffd.FixedOrBitSize;
        var bitOffset = ffd.BitOffset;
        var bitSizeWithOffset = size << 32 | bitOffset;


        var typeName = $"Bit{size}_{bitOffset}";
        var code = CachedBitCode.GetOrAdd(bitSizeWithOffset, x =>
        {
            var bitSizeAndOffset = size + bitOffset;
            var baseType = GetBaseTypeByBitSizeAndOffset(bitSizeAndOffset, ffd.TypeName);
            return $@"
public struct Bit{size}_{bitOffset} : IEquatable<{typeName}>
{{
    public const {baseType} Max = {GetMaxByBitCount(size)};
    public const {baseType} Min = {0};

    public {baseType} Value;
    public {typeName} ({baseType}  x) => Value = x;

    public bool Equals({typeName} other) => Value == other.Value;
    public override bool Equals(object obj) => obj is {typeName} other && Equals(other);
    public override int GetHashCode() => Value.GetHashCode();
    public static bool operator ==({typeName} x, {typeName} y) => x.Value == y.Value;
    public static bool operator !=({typeName} x, {typeName} y) => x.Value != y.Value;

    public static implicit operator {typeName}({baseType} x) => new {typeName}(x);
    public static implicit operator {baseType}({typeName} x) => x.Value;

    public override string ToString() => Value.ToString();
}}";
        });
        StringBuilder sb = new StringBuilder();
        sb.Append(FixedFileHead);
        sb.Append(code);
        //foreach (var typeCode in CachedBitCode.Values)
        //    sb.AppendLine(typeCode);
        spc.AddSource($"{typeName}.g.cs", sb.ToString());

    }


    //public void GenerateFixedAttribute(SourceProductionContext sourceProductionContext,GeneratorAttributeSyntaxContext generatorAttributeSyntaxContext)
    //{

    //    if (generatorAttributeSyntaxContext.TargetSymbol is not INamedTypeSymbol symbol)
    //        return;

    //  foreach(var attribute in generatorAttributeSyntaxContext.Attributes)//  AttributeData attribute = context.Attributes .FirstOrDefault(a => a.AttributeClass.Name == "EventApplyAttribute");
    //    {
    //        //attribute.NamedArguments
    //        //attribute.ConstructorArguments.Where(tc=>tc.Value)

    //        var size = (int)attribute.ConstructorArguments[0].Value!;//这里FixedAttribute只有一个必填参数
    //        var genericTypes = attribute.AttributeConstructor.TypeParameters;
    //        genericTypes[0]


    //        var ms = attribute.AttributeConstructor;
    //        ms.ContainingType
    //        var source = string.Format(StructTemplate, size);

    //        sourceProductionContext.AddSource(
    //        // 不能重名
    //            $"{symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted))}_{attribute.Key}.g.cs",
    //            source);

    //    }

    //}

    public bool FilterSyntaxTargetForGeneration(SyntaxNode syntaxNode, CancellationToken _)
        => syntaxNode.IsStructFieldOrIncompleteMember();

    /// <summary>
    /// 获取TypeDeclarationSyntax
    /// </summary>
    private static FixedOrBitMemberDesc? FilterSemanticTargetForGeneration(GeneratorSyntaxContext context, CancellationToken _)
    {
        //context.SemanticModel.LookupSymbols(()
        //context.SemanticModel.LookupNamespacesAndTypes()
        //context.SemanticModel.GetDeclaredSymbol()
        if (FixedOrBitMemberDesc.Get(context.Node, out var fds, out var ts))
        {
            //var declaredSymbol = context.SemanticModel?.GetDeclaredSymbol(ts);
            ////var symbolInfo = context.SemanticModel?.GetSymbolInfo(ts);
            ////Debugger.Launch();
            //if (declaredSymbol?.IsDefinition != true)
                return fds;
        }

        return null;
    }

    //context.SemanticModel.GetDeclaredSymbol(fieldDeclarationSyntax1);
    //context.SemanticModel.GetDeclaredSymbol(fieldDeclarationSyntax1.Declaration.Type);
    //context.SemanticModel.GetSymbolInfo(fieldDeclarationSyntax1);

    //public GeneratorSyntaxContext Generate(GeneratorSyntaxContext generatorSyntaxContext, CancellationToken _)
    //{
    //    if (generatorSyntaxContext.Node is StructDeclarationSyntax structDeclaration)
    //    {
    //        //添加 public unsafe partial struct
    //    }

    //    var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;

    //    string baseTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
    //        .Replace("global::", "")
    //        .Replace("<", "_")
    //        .Replace(">", "_");
    //    generatorSyntaxContext.
    //    emitParams.Context.AddSource($"{emitParams.BaseFileName}.g.cs", codeBuilder.ToString());

    //    return generatorSyntaxContext;
    //}


    private static int Count { set; get; } = 0;
    public void Step1_FindFiles(IncrementalGeneratorInitializationContext context)
    {
        //context.SyntaxProvider
        IncrementalValueProvider<Compilation> compilations =
            context.CompilationProvider.Select((compilation, cancellationToken) => compilation);
        //IncrementalValuesProvider<AdditionalText> textFiles = context.AdditionalTextsProvider.Where(static file => file.Path.EndsWith(".txt"));

        context.RegisterSourceOutput(compilations, (sourceProductionContext, compilation) =>
        {
            var syntaxTree = compilation.SyntaxTrees.FirstOrDefault();
            if (syntaxTree == null)
            {
                return;
            }

            var root = syntaxTree.GetRoot(sourceProductionContext.CancellationToken);

            // 选择给 Program 的附加上
            var classDeclarationSyntax = root
                .DescendantNodes(descendIntoTrivia: true)
                .OfType<ClassDeclarationSyntax>()
                .FirstOrDefault();
            if (classDeclarationSyntax?.Identifier.Text != "Program")
            {
                // 如果变更的非预期类型，那就不加上代码，否则代码将会重复加入
                return;
            }

            string source = @"
using System;

namespace WhacadenaKewarfellaja
{
    public static partial class Program
    {
        static partial void HelloFrom(string name)
        {
            Console.WriteLine($""Says: Hi from '{name}'"");
        }
    }
}
";
            sourceProductionContext.AddSource("GeneratedSourceTest", source);


            //string source = $@"Console.WriteLine(""构建 {Count} 次"");";
            //sourceProductionContext.AddSource("GeneratedSourceTest", source);

            Count++;
            Debug.WriteLine($"构建 {Count} 次");


        });

    }
    //public static IncrementalValueProvider<TResult> Select<TSource, TResult>(this IncrementalValueProvider<TSource> source, Func<TSource, CancellationToken, TResult> selector)
    //{

    //}
}
