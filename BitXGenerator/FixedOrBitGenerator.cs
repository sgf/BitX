using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Differencing;
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Text;
using System.Xml.Linq;

namespace BitX;

[Generator(LanguageNames.CSharp)]
public partial class FixedOrBitGenerator : IIncrementalGenerator
{

    public const string FixedFileHead = @"// <auto-generated/>
#nullable enable
#pragma warning disable CS0108
#pragma warning disable CS0162
#pragma warning disable CS0164
#pragma warning disable CS0219
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8604
#pragma warning disable CS8619
#pragma warning disable CS8620
#pragma warning disable CS8631
#pragma warning disable CS8765
#pragma warning disable CS9074
#pragma warning disable CA1050

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System;";




    private static string GetBaseTypeByBitSizeAndOffset(int bitSizeAndOffset, string typeName) =>
       bitSizeAndOffset switch
       {
           <= 8 => "byte",
           <= 16 => "ushort",
           <= 32 => "uint",
           <= 64 => "ulong",
           _ => throw new ArgumentException($"unsupported bit Size And Offset: {bitSizeAndOffset}", typeName),
           //<= 128 => "UInt128",
       };

    public static ulong GetMaxByBitCount(int bitCount)
    {
        ulong result = 0;
        for (var i = 0; i < bitCount; i++)
            result |= (1UL << i);//此处或运算亦可为加运算

        //直接使用次方API实现,暂不使用此方法.
        //        if (input > 0)
        //            output = (UInt64)Math.Pow(2, (int)input) - 1;
        return result;
    }

    //private static Dictionary<string, FixedOrBitMemberDesc> list = [];
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {

        var generatorAttributes = context.SyntaxProvider.ForAttributeWithMetadataName(
            "BitX.BitXAttribute",
            (x, _) =>
        {
            return x is StructDeclarationSyntax sds && sds.Members.Any(m => m.IsFieldOrIncompleteMember()
            && ((m is IncompleteMemberSyntax ims && ims!.GetTypeDesc(out var td1)) ||
            (m is FieldDeclarationSyntax _fds && _fds.GetTypeDesc(out var td2))) );
        }
        ,
            (sctx, _) =>
            {
                Dictionary<string, FixedOrBitMemberDesc> list = [];
                foreach (var m in ((StructDeclarationSyntax)sctx.TargetNode).Members.Where(m => m.IsFieldOrIncompleteMember()))
                {
                    if (!FixedOrBitMemberDesc.Get(m, out var fds, out var ts)) continue;
                    if (!list.ContainsKey(fds.TypeName))
                        list.Add(fds.TypeName, fds);
                }
                //if (list.Values.Count == 0)
                //{
                //    if (!Debugger.IsAttached)
                //        Debugger.Launch();
                //}
                return list;
            }

        );



        context.RegisterSourceOutput(generatorAttributes, (spc, ga) =>
        {

            foreach (var fds in ga.Values)
            {
                if (fds.IsFixedOrBit)
                    FixedBufferGenerate(spc, fds);
                else
                    BitFieldTypeGenerate(spc, fds);
            }
        });

        //context.RegisterSourceOutput(generatorAttributes, (spc, ga) =>
        //{
        //    var typeSymbol = (INamedTypeSymbol)ga.TargetSymbol;
        //    var typeNode = (TypeDeclarationSyntax)ga.TargetNode;
        //    foreach (var m in typeNode.Members)
        //    {
        //        if (!m.IsStructFieldOrIncompleteMember()) continue;
        //        if (!FixedOrBitMemberDesc.Get(m, out var fds, out var ts)) continue;

        //        if (fds.IsFixedOrBit)
        //            FixedBufferGenerate(spc, fds);
        //        else
        //            BitFieldTypeGenerate(spc, fds);
        //    }
        //});

        //var incrementalValuesProvider = context.SyntaxProvider.CreateSyntaxProvider(
        //    FilterSyntaxTargetForGeneration
        //    , FilterSemanticTargetForGeneration);


        //context.RegisterSourceOutput(incrementalValuesProvider, static (spc, ffd) =>
        //{
        //    if (ffd.HasValue)
        //    {
        //        if (ffd.Value.IsFixedOrBit)
        //            FixedBufferGenerate(spc, ffd.Value);
        //        else
        //            BitFieldTypeGenerate(spc, ffd.Value);
        //    }
        //});

        //Log.FlushLogs(context);
    }

    private static void FixedBufferGenerate(SourceProductionContext spc, FixedOrBitMemberDesc ffd)
    {
        var code = $@"{FixedFileHead}
[InlineArray({ffd.FixedOrBitSize})]
public struct {ffd.TypeName}<T>
{{
    private T _element0;

    public const int Length = {ffd.FixedOrBitSize};

    public Span<T> GetSpan() => MemoryMarshal.CreateSpan(ref Unsafe.As<Fixed{ffd.FixedOrBitSize}<T>, T>(ref this), {ffd.FixedOrBitSize});

    T this[int index] {{ get => this[index]; set => this[index] = value; }}
}}";
        spc.AddSource($"Fixed{ffd.FixedOrBitSize}.g.cs", code);
    }



    private static void BitFieldTypeGenerate(SourceProductionContext spc, FixedOrBitMemberDesc ffd)
    {
        var size = ffd.FixedOrBitSize;
        var bitOffset = ffd.BitOffset;
        //var bitSizeWithOffset = (long)size << 32 | bitOffset;
        var bitSizeAndOffset = size + bitOffset;
        var baseType = GetBaseTypeByBitSizeAndOffset(bitSizeAndOffset, ffd.TypeName);
        var code = $@"{FixedFileHead}
public struct {ffd.TypeName} : IEquatable<{ffd.TypeName}>
{{
    public const {baseType} Max = {GetMaxByBitCount(size)};
    public const {baseType} Min = {0};

    public {baseType} Value;
    public {ffd.TypeName} ({baseType}  x) => Value = x;

    public bool Equals({ffd.TypeName} other) => Value == other.Value;
    public override bool Equals(object obj) => obj is {ffd.TypeName} other && Equals(other);
    public override int GetHashCode() => Value.GetHashCode();
    public static bool operator ==({ffd.TypeName} x, {ffd.TypeName} y) => x.Value == y.Value;
    public static bool operator !=({ffd.TypeName} x, {ffd.TypeName} y) => x.Value != y.Value;

    public static implicit operator {ffd.TypeName}({baseType} x) => new {ffd.TypeName}(x);
    public static implicit operator {baseType}({ffd.TypeName} x) => x.Value;

    public override string ToString() => Value.ToString();
}}";

        spc.AddSource($"{ffd.TypeName}.g.cs", code);

    }

    public bool FilterSyntaxTargetForGeneration(SyntaxNode syntaxNode, CancellationToken _)
        => syntaxNode.IsStructFieldOrIncompleteMember();

    /// <summary>
    /// 获取TypeDeclarationSyntax
    /// </summary>
    private static FixedOrBitMemberDesc? FilterSemanticTargetForGeneration(GeneratorSyntaxContext context, CancellationToken _)
    {
        SyntaxNode syntaxNode = context.Node;
        if (FixedOrBitMemberDesc.Get(syntaxNode, out var fds, out var ts))
        {
            return fds;
        }

        return null;
    }

}
