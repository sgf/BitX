using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace BitX;

[Generator(LanguageNames.CSharp)]
public partial class FixedOrBitGenerator : IIncrementalGenerator
{
    public const string FixedFileHead = @"// <auto-generated/>
#nullable enable
#pragma warning disable CS0108
#pragma warning disable CS0162
#pragma warning disable CS0164
#pragma warning disable CS0219
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8604
#pragma warning disable CS8619
#pragma warning disable CS8620
#pragma warning disable CS8631
#pragma warning disable CS8765
#pragma warning disable CS9074
#pragma warning disable CA1050

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System;

";

    private static string GetBaseTypeByBitSizeAndOffset(int bitSizeAndOffset, string typeName) =>
       bitSizeAndOffset switch
       {
           <= 8 => "byte",
           <= 16 => "ushort",
           <= 32 => "uint",
           <= 64 => "ulong",
           _ => throw new ArgumentException($"unsupported bit Size And Offset: {bitSizeAndOffset}", typeName),
           //<= 128 => "UInt128",
       };

    public static ulong GetMaxByBitCount(int bitCount)
    {
        ulong result = 0;
        for (var i = 0; i < bitCount; i++)
            result |= (1UL << i);//此处或运算亦可为加运算

        //直接使用次方API实现,暂不使用此方法.
        //        if (input > 0)
        //            output = (UInt64)Math.Pow(2, (int)input) - 1;
        return result;
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var initialModels = context.SyntaxProvider.ForAttributeWithMetadataName(
            "BitX.BitXAttribute",
            (x, _) =>
            {
                return x.IsStruct() && x is StructDeclarationSyntax sds && sds.Members.Any(m => m.IsFieldOrIncompleteMember());
                //TypeDesc td = default;
                //    x is StructDeclarationSyntax sds && sds.Members.Any(m => m.IsFieldOrIncompleteMember()
                //&& ((m is IncompleteMemberSyntax ims && ims.GetTypeDesc(out td)) ||
                //(m is FieldDeclarationSyntax _fds && _fds.GetTypeDesc(out td))));
            }
            , (sctx, _) => ((StructDeclarationSyntax)sctx.TargetNode).Members.Where(m => m.IsFieldOrIncompleteMember()).Select(m =>
            {
                TypeDesc td = default;
                if ((m is IncompleteMemberSyntax ims && ims!.GetTypeDesc(out td))
                || (m is FieldDeclarationSyntax _fds && _fds.GetTypeDesc(out td)))
                    return (true, td);
                return default;
            })
        );

        var finalModel = initialModels.Collect()
            .Select((models, cancellationToken) => new HashSet<TypeDesc>(models.SelectMany(m => m.Where(x => x.Item1).Select(x => x.td))));
        context.RegisterSourceOutput(finalModel, (spc, tds) =>
        {
            FixedBufferGenerate(spc, tds.Where(dd => dd.IsFixed));
            BitFieldTypeGenerate(spc, tds.Where(dd => dd.IsBit));
        });

        //Log.FlushLogs(context);
    }

    private static void FixedBufferGenerate(SourceProductionContext spc, IEnumerable<TypeDesc> ffds)
    {
        StringBuilder csb = new($@"{FixedFileHead}");

        foreach (var ffd in ffds)
        {
            csb.AppendLine($@"
[InlineArray({ffd.FixedOrBitSize})]
public struct {ffd.Name}<T>
{{
    private T _element0;

    public const int Length = {ffd.FixedOrBitSize};

    public Span<T> GetSpan() => MemoryMarshal.CreateSpan(ref Unsafe.As<Fixed{ffd.FixedOrBitSize}<T>, T>(ref this), {ffd.FixedOrBitSize});

    T this[int index] {{ get => this[index]; set => this[index] = value; }}
}}");
        }

        spc.AddSource($"Fixed.g.cs", csb.ToString());
    }



    private static void BitFieldTypeGenerate(SourceProductionContext spc, IEnumerable<TypeDesc> ffds)
    {
        StringBuilder csb = new($@"{FixedFileHead}");

        foreach (var ffd in ffds)
        {
            var size = ffd.FixedOrBitSize;
            var bitOffset = ffd.BitOffset;
            //var bitSizeWithOffset = (long)size << 32 | bitOffset;
            var baseType = GetBaseTypeByBitSizeAndOffset(bitOffset + size, ffd.Name);
            csb.AppendLine($@"
public struct {ffd.Name} : IEquatable<{ffd.Name}>
{{

    public const int Size = {size};
    public const {baseType} Max = {GetMaxByBitCount(size)};
    public const {baseType} Min = {0};

    public {baseType} Value;
    public {ffd.Name} ({baseType}  x) => Value = x;

    public bool Equals({ffd.Name} other) => Value == other.Value;
    public override bool Equals(object obj) => obj is {ffd.Name} other && Equals(other);
    public override int GetHashCode() => Value.GetHashCode();
    public static bool operator ==({ffd.Name} x, {ffd.Name} y) => x.Value == y.Value;
    public static bool operator !=({ffd.Name} x, {ffd.Name} y) => x.Value != y.Value;

    public static implicit operator {ffd.Name}({baseType} x) => new {ffd.Name}(x);
    public static implicit operator {baseType}({ffd.Name} x) => x.Value;

    public override string ToString() => Value.ToString();
}}");
        }

        spc.AddSource($"BitFields.g.cs", csb.ToString());

    }

    public bool FilterSyntaxTargetForGeneration(SyntaxNode syntaxNode, CancellationToken _)
        => syntaxNode.IsStructFieldOrIncompleteMember();

}
