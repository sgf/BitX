using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Differencing;
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml.Linq;

namespace BitX;

[Generator(LanguageNames.CSharp)]
public partial class FixedOrBitGenerator : IIncrementalGenerator
{

    public const string FixedFileHead = @"// <auto-generated/>
#nullable enable
#pragma warning disable CS0108
#pragma warning disable CS0162
#pragma warning disable CS0164
#pragma warning disable CS0219
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8604
#pragma warning disable CS8619
#pragma warning disable CS8620
#pragma warning disable CS8631
#pragma warning disable CS8765
#pragma warning disable CS9074
#pragma warning disable CA1050

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System;";




    private static string GetBaseTypeByBitSizeAndOffset(int bitSizeAndOffset, string typeName) =>
       bitSizeAndOffset switch
       {
           <= 8 => "byte",
           <= 16 => "ushort",
           <= 32 => "uint",
           <= 64 => "ulong",
           _ => throw new ArgumentException($"unsupported bit Size And Offset: {bitSizeAndOffset}", typeName),
           //<= 128 => "UInt128",
       };

    public static ulong GetMaxByBitCount(int bitCount)
    {
        ulong result = 0;
        for (var i = 0; i < bitCount; i++)
            result |= (1UL << i);//此处或运算亦可为加运算

        //直接使用次方API实现,暂不使用此方法.
        //        if (input > 0)
        //            output = (UInt64)Math.Pow(2, (int)input) - 1;
        return result;
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {

        var generatorAttributes = context.SyntaxProvider.ForAttributeWithMetadataName(
            "BitX.BitXAttribute",
            (x, _) => true,
            (syntaxContext, _) => syntaxContext
        );

        context.RegisterSourceOutput(generatorAttributes, (spc, ga) =>
        {
            var typeSymbol = (INamedTypeSymbol)ga.TargetSymbol;
            var typeNode = (TypeDeclarationSyntax)ga.TargetNode;
            foreach (var m in typeNode.Members)
            {
                if (!m.IsStructFieldOrIncompleteMember()) continue;
                if (!FixedOrBitMemberDesc.Get(m, out var fds, out var ts)) continue;

                if (fds.IsFixedOrBit)
                    FixedBufferGenerate(spc, fds);
                else
                    BitFieldTypeGenerate(spc, fds);
            }
        });

        //var incrementalValuesProvider = context.SyntaxProvider.CreateSyntaxProvider(
        //    FilterSyntaxTargetForGeneration
        //    , FilterSemanticTargetForGeneration);


        //context.RegisterSourceOutput(incrementalValuesProvider, static (spc, ffd) =>
        //{
        //    if (ffd.HasValue)
        //    {
        //        if (ffd.Value.IsFixedOrBit)
        //            FixedBufferGenerate(spc, ffd.Value);
        //        else
        //            BitFieldTypeGenerate(spc, ffd.Value);
        //    }
        //});

        //Log.FlushLogs(context);
    }

    private static void FixedBufferGenerate(SourceProductionContext spc, FixedOrBitMemberDesc ffd)
    {
        var code = $@"{FixedFileHead}
[InlineArray({ffd.FixedOrBitSize})]
public struct Fixed{ffd.FixedOrBitSize}<T>
{{
    private T _element0;

    public const int Length = {ffd.FixedOrBitSize};

    public Span<T> GetSpan() => MemoryMarshal.CreateSpan(ref Unsafe.As<Fixed{ffd.FixedOrBitSize}<T>, T>(ref this), {ffd.FixedOrBitSize});

    T this[int index] {{ get => this[index]; set => this[index] = value; }}
}}"; 
        spc.AddSource($"Fixed{ffd.FixedOrBitSize}.g.cs", code);
    }



    private static void BitFieldTypeGenerate(SourceProductionContext spc, FixedOrBitMemberDesc ffd)
    {
        var size = ffd.FixedOrBitSize;
        var bitOffset = ffd.BitOffset;
        //var bitSizeWithOffset = (long)size << 32 | bitOffset;
        var bitSizeAndOffset = size + bitOffset;
        var typeName = $"Bit{size}_{bitOffset}";
        var baseType = GetBaseTypeByBitSizeAndOffset(bitSizeAndOffset, ffd.TypeName);
        var code =  $@"{FixedFileHead}
public struct Bit{size}_{bitOffset} : IEquatable<{typeName}>
{{
    public const {baseType} Max = {GetMaxByBitCount(size)};
    public const {baseType} Min = {0};

    public {baseType} Value;
    public {typeName} ({baseType}  x) => Value = x;

    public bool Equals({typeName} other) => Value == other.Value;
    public override bool Equals(object obj) => obj is {typeName} other && Equals(other);
    public override int GetHashCode() => Value.GetHashCode();
    public static bool operator ==({typeName} x, {typeName} y) => x.Value == y.Value;
    public static bool operator !=({typeName} x, {typeName} y) => x.Value != y.Value;

    public static implicit operator {typeName}({baseType} x) => new {typeName}(x);
    public static implicit operator {baseType}({typeName} x) => x.Value;

    public override string ToString() => Value.ToString();
}}";

        spc.AddSource($"{typeName}.g.cs", code);

    }

    public bool FilterSyntaxTargetForGeneration(SyntaxNode syntaxNode, CancellationToken _)
        => syntaxNode.IsStructFieldOrIncompleteMember();

    /// <summary>
    /// 获取TypeDeclarationSyntax
    /// </summary>
    private static FixedOrBitMemberDesc? FilterSemanticTargetForGeneration(GeneratorSyntaxContext context, CancellationToken _)
    {
        SyntaxNode syntaxNode = context.Node;
        if (FixedOrBitMemberDesc.Get(syntaxNode, out var fds, out var ts))
        {
            return fds;
        }

        return null;
    }

}
